\label{index_md_docs_index}%
\Hypertarget{index_md_docs_index}%
 Welcome to the \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}} documentation. This code provide classes to simulate \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}} by dicretizing it into \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}}.\hypertarget{index_autotoc_md1}{}\doxysection{Structure of the library}\label{index_autotoc_md1}
This library provide \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} and \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}} modules to simulate the \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}} by discretizing it into a finit number of elements. Tether are constitued by a doubly linked list of \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} such that each \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} own a std\+::shared\+\_\+ptr to its neighbors. On each \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} are applied its weight depending on its mass, its buoyancy depending on its volume, its hydrodynamics drag force. The force applied on each \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} from its neighbors is a behavioral force based on a PID cocntroller to reach the correct distance between each \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}}.\hypertarget{index_autotoc_md2}{}\doxysection{Examples}\label{index_autotoc_md2}
Here is some basic examples to use modules provided by this library.\hypertarget{index_autotoc_md3}{}\doxysubsection{Tether\+Element basics}\label{index_autotoc_md3}
Example of \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} use. To instanciate a \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} you need to give its mass $m$, its volume $v$, the target length $l$ of the links between each \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} and optionnally an initial state vector $X_0 (x_0, y_0, z_0)$. Then you can access to the \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} parameters and state, and you can update its state by simulating a new step with a time-\/step $h$.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{TetherElement_8hpp}{TetherElement.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <Eigen/Dense>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using namespace }tether;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{char}*[]) \{}
\DoxyCodeLine{    \textcolor{comment}{// TetherElement parameters}}
\DoxyCodeLine{    std::double\_t mass = 0.5;}
\DoxyCodeLine{    std::double\_t volume = 0.1;}
\DoxyCodeLine{    std::double\_t length = 0.02;}
\DoxyCodeLine{    Eigen::Vector3d X0(1.0, 2.0, 3.0);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Create a TetherElement}}
\DoxyCodeLine{    TetherElement tether\_element(mass, volume, length, X0);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Accessing TetherElement parameters}}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}>> TetherElement parameters"{}} << std::endl;}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}mass \(\backslash\)t: "{}} << tether\_element.Mass() << std::endl;}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}volume \(\backslash\)t: "{}} << tether\_element.Volume() << std::endl;}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}length \(\backslash\)t: "{}} << tether\_element.Length() << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Accessing TetherElement state}}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}>> TetherElement state"{}} << std::endl;}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}x \(\backslash\)t: "{}} << tether\_element.X() << std::endl;}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}y \(\backslash\)t: "{}} << tether\_element.Y() << std::endl;}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}z \(\backslash\)t: "{}} << tether\_element.Z() << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Update the state from t to t + h}}
\DoxyCodeLine{    std::double\_t h = 0.01;}
\DoxyCodeLine{    tether\_element.Step(h);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} EXIT\_SUCCESS;}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
\hypertarget{index_autotoc_md4}{}\doxysubsection{Tether basics}\label{index_autotoc_md4}
Example of \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}} use. To instanciate a \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}}, you need to give the initial length $L$ of the \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}} and number of \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} $n$ which will be used to simulate the \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}}. Then you can access to the \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}} parameters and you can update the state of the \mbox{\hyperlink{classtether_1_1Tether}{tether\+::\+Tether}} by providing a time-\/step $h$. This method will browse the doubly linked list and to call each \mbox{\hyperlink{classtether_1_1TetherElement}{tether\+::\+Tether\+Element}} step method.


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{Tether_8hpp}{Tether.hpp}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{TetherElement_8hpp}{TetherElement.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using namespace }tether;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{char}*[]) \{}
\DoxyCodeLine{    \textcolor{comment}{// Tether parameters}}
\DoxyCodeLine{    std::double\_t length = 10;}
\DoxyCodeLine{    std::size\_t n = 100;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Create a Tether}}
\DoxyCodeLine{    Tether tether(length, n);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Accessing Tether parameters}}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}>> Tether parameters"{}} << std::endl;}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}n \(\backslash\)t: "{}} << tether.N() << std::endl;}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}length \(\backslash\)t: "{}} << tether.Length() << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Update the state from t to t + h}}
\DoxyCodeLine{    std::double\_t h = 0.01;}
\DoxyCodeLine{    tether.Step(h);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} EXIT\_SUCCESS;}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
 